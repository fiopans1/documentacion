# GU√çA SOBRE JDBC

## üß≠ √çndice de la gu√≠a

1. **¬øQu√© es JDBC?**
2. **Configuraci√≥n inicial**
3. **Conexi√≥n a la base de datos**
4. **Crear una consulta (`Statement`, `PreparedStatement`)**
5. **Usar el `ResultSet` y recorrer resultados**
6. **Cerrar conexiones correctamente**
7. **Ejemplo completo**
8. **Buenas pr√°cticas**
9. **Errores comunes**
10. **Siguientes pasos: Transacciones, batch y CallableStatement**

Perfecto, vamos con la **Secci√≥n 1: ¬øQu√© es JDBC?**

---

## 1. ¬øQu√© es JDBC?

**JDBC** (Java Database Connectivity) es una API (Application Programming Interface) de Java que permite a las aplicaciones Java interactuar con bases de datos relacionales (como MySQL, PostgreSQL, Oracle, SQL Server, etc.).

JDBC define un conjunto de clases e interfaces que permiten:

- Conectarse a una base de datos.
- Ejecutar consultas SQL.
- Obtener y recorrer los resultados.
- Ejecutar sentencias de actualizaci√≥n (INSERT, UPDATE, DELETE).
- Manejar transacciones.

---

### üîå ¬øC√≥mo funciona JDBC?

1. **Driver JDBC**: Es un puente entre Java y el motor de base de datos. Cada base de datos tiene su propio driver JDBC que debe a√±adirse al proyecto.
2. **Connection**: Abre una conexi√≥n con la base de datos.
3. **Statement / PreparedStatement**: Permiten ejecutar consultas SQL.
4. **ResultSet**: Representa los resultados de una consulta `SELECT`.
5. **Cerrar recursos**: Siempre es importante cerrar `Connection`, `Statement` y `ResultSet`.

---

### üì¶ Paquetes principales de JDBC

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
```

---

### üèõÔ∏è Arquitectura JDBC (simplificada)

```
Aplicaci√≥n Java
      ‚Üì
 JDBC API (java.sql)
      ‚Üì
JDBC Driver (Proveedor espec√≠fico)
      ‚Üì
Base de Datos
```

---

## 2. Configuraci√≥n inicial

Antes de empezar a usar JDBC, necesitas tener configurado tu entorno de desarrollo y tener acceso a una base de datos.

---

### ‚úÖ Requisitos previos

- **Java instalado** (JDK 8 o superior)
- **Un entorno de desarrollo** (como IntelliJ IDEA, Eclipse o VS Code)
- **Una base de datos** instalada o accesible (por ejemplo: MySQL, PostgreSQL, H2, SQLite, etc.)
- **El driver JDBC** correspondiente a tu base de datos

---

### üì• A√±adir el driver JDBC

#### a) Si usas **Maven**

A√±ade la dependencia correspondiente en el `pom.xml`.

Por ejemplo, para **MySQL**:

```xml
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>8.0.33</version>
</dependency>
```

Para **PostgreSQL**:

```xml
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.7.1</version>
</dependency>
```

#### b) Si no usas Maven

Descarga el `.jar` del driver desde la web oficial y a√±√°delo al classpath de tu proyecto manualmente.

---

### üõ†Ô∏è Crear una base de datos de prueba

Por ejemplo, en MySQL podr√≠as ejecutar:

```sql
CREATE DATABASE testdb;

USE testdb;

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100)
);

INSERT INTO users (name, email) VALUES ('Ana', 'ana@email.com');
INSERT INTO users (name, email) VALUES ('Luis', 'luis@email.com');
```

---

### üß™ Prueba de conexi√≥n r√°pida

Lo veremos m√°s en detalle en la siguiente secci√≥n, pero aqu√≠ va un ejemplo b√°sico:

```java
String url = "jdbc:mysql://localhost:3306/testdb";
String user = "root";
String password = "tu_contrase√±a";

try (Connection conn = DriverManager.getConnection(url, user, password)) {
    System.out.println("¬°Conectado a la base de datos!");
} catch (SQLException e) {
    e.printStackTrace();
}
```

---

## 3. Conexi√≥n a la base de datos

El primer paso pr√°ctico con JDBC es establecer una conexi√≥n entre tu aplicaci√≥n Java y la base de datos.

---

### üîÑ Pasos para conectarse

1. **Definir los datos de conexi√≥n**
2. **Usar `DriverManager` para obtener la conexi√≥n**
3. **Controlar errores con `try-catch` y cerrar bien los recursos**

---

### üìå Estructura t√≠pica

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConexionBD {
    public static void main(String[] args) {
        String url = "jdbc:mysql://localhost:3306/testdb"; // Cambia testdb por tu base
        String user = "root"; // Tu usuario
        String password = "tu_contrase√±a"; // Tu contrase√±a

        try (Connection conn = DriverManager.getConnection(url, user, password)) {
            if (conn != null) {
                System.out.println("‚úÖ Conexi√≥n establecida correctamente.");
            }
        } catch (SQLException e) {
            System.out.println("‚ùå Error al conectar con la base de datos:");
            e.printStackTrace();
        }
    }
}
```

---

### üß† Explicaci√≥n de `DriverManager.getConnection`

Este m√©todo recibe:

- **URL de conexi√≥n**: indica el tipo de base de datos, el host, el puerto y el nombre de la base.

  - Ejemplos:
    - MySQL: `jdbc:mysql://localhost:3306/testdb`
    - PostgreSQL: `jdbc:postgresql://localhost:5432/testdb`
    - SQLite: `jdbc:sqlite:ruta/a/miarchivo.db`

- **Usuario** y **contrase√±a** de la base de datos

---

### üìå Detalles importantes

- **No es necesario registrar el driver manualmente** (con `Class.forName(...)`) si usas JDBC 4.0+ y el driver est√° bien en el classpath. Java lo carga autom√°ticamente.
- Siempre usa `try-with-resources` para cerrar autom√°ticamente la conexi√≥n.
- Es importante manejar bien los errores (`SQLException`).

---

## 4. Crear una consulta con `Statement` y `PreparedStatement`

Una vez que est√°s conectado a la base de datos, el siguiente paso es ejecutar consultas SQL. En JDBC se pueden usar dos formas principales:

- `Statement`: para consultas simples (no recomendada si hay par√°metros din√°micos).
- `PreparedStatement`: para consultas con par√°metros (m√°s segura y eficiente).

---

### üéØ ¬øCu√°l es la diferencia clave?

| Tipo                | ¬øPar√°metros? | ¬øSeguridad contra SQL Injection? | ¬øM√°s eficiente en consultas repetidas? |
| ------------------- | ------------ | -------------------------------- | -------------------------------------- |
| `Statement`         | ‚ùå No        | ‚ùå No                            | ‚ùå No                                  |
| `PreparedStatement` | ‚úÖ S√≠        | ‚úÖ S√≠                            | ‚úÖ S√≠                                  |

---

### üß™ Ejemplo con `Statement`

```java
String sql = "SELECT * FROM users";

try (Connection conn = DriverManager.getConnection(url, user, password);
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery(sql)) {

    while (rs.next()) {
        System.out.println("ID: " + rs.getInt("id"));
        System.out.println("Nombre: " + rs.getString("name"));
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### üîê Ejemplo con `PreparedStatement`

```java
String sql = "SELECT * FROM users WHERE name = ?";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql)) {

    pstmt.setString(1, "Ana"); // Primer par√°metro: nombre

    try (ResultSet rs = pstmt.executeQuery()) {
        while (rs.next()) {
            System.out.println("ID: " + rs.getInt("id"));
            System.out.println("Email: " + rs.getString("email"));
        }
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### üß† M√©todos comunes de `PreparedStatement`

```java
pstmt.setInt(posici√≥n, valor);      // Para enteros
pstmt.setString(posici√≥n, valor);   // Para strings
pstmt.setDouble(posici√≥n, valor);   // Para decimales
pstmt.setDate(posici√≥n, valor);     // Para fechas (java.sql.Date)
```

---

## 5. Usar `ResultSet` y recorrer los resultados

Cuando ejecutas una consulta `SELECT`, el m√©todo `executeQuery()` te devuelve un objeto de tipo `ResultSet`. Este representa una tabla en memoria con los resultados obtenidos.

---

### üß± Estructura b√°sica

```java
ResultSet rs = statement.executeQuery("SELECT * FROM users");

while (rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    String email = rs.getString("email");

    System.out.println("ID: " + id + ", Nombre: " + name + ", Email: " + email);
}
```

---

### üîÑ ¬øC√≥mo funciona `rs.next()`?

- `rs.next()` mueve el cursor a la siguiente fila del resultado.
- La primera vez que lo llamas, se mueve de antes de la primera fila ‚Üí a la primera.
- Devuelve `false` si ya no hay m√°s filas.

---

### üîç M√©todos para obtener datos

| M√©todo                    | Tipo de dato                        |
| ------------------------- | ----------------------------------- |
| `getInt("columna")`       | Entero                              |
| `getString("columna")`    | Cadena                              |
| `getBoolean("columna")`   | Booleano                            |
| `getDouble("columna")`    | Decimal                             |
| `getDate("columna")`      | Fecha (`java.sql.Date`)             |
| `getTimestamp("columna")` | Fecha y hora (`java.sql.Timestamp`) |

Tambi√©n puedes usar √≠ndices:

```java
int id = rs.getInt(1);       // primera columna
String name = rs.getString(2); // segunda columna
```

Pero usar nombres de columna es m√°s claro y resistente a cambios.

---

### ‚úÖ Ejemplo completo

```java
String sql = "SELECT id, name, email FROM users";

try (Connection conn = DriverManager.getConnection(url, user, password);
     Statement stmt = conn.createStatement();
     ResultSet rs = stmt.executeQuery(sql)) {

    while (rs.next()) {
        int id = rs.getInt("id");
        String name = rs.getString("name");
        String email = rs.getString("email");

        System.out.printf("ID: %d - Nombre: %s - Email: %s%n", id, name, email);
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

## 6. Cerrar conexiones correctamente

Uno de los errores m√°s comunes y peligrosos al usar JDBC es **no cerrar bien los recursos**. Si dejas conexiones abiertas, puedes agotar el n√∫mero m√°ximo de conexiones permitidas por la base de datos, lo que puede tumbar tu aplicaci√≥n.

---

### üß± Recursos que se deben cerrar

En orden de apertura:

1. `ResultSet`
2. `Statement` / `PreparedStatement`
3. `Connection`

Todos implementan la interfaz `AutoCloseable`, lo que permite usar `try-with-resources` (desde Java 7).

---

### ‚úÖ Forma correcta: try-with-resources

```java
String sql = "SELECT * FROM users";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql);
     ResultSet rs = pstmt.executeQuery()) {

    while (rs.next()) {
        System.out.println(rs.getString("name"));
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

> üí° Esta forma **cierra autom√°ticamente** todos los recursos al salir del bloque `try`, incluso si hay una excepci√≥n.

---

### ‚ùå Forma incorrecta: sin cerrar o cerrando mal

```java
Connection conn = null;
PreparedStatement pstmt = null;
ResultSet rs = null;

try {
    conn = DriverManager.getConnection(...);
    pstmt = conn.prepareStatement("SELECT ...");
    rs = pstmt.executeQuery();

    // usar rs...

} catch (SQLException e) {
    e.printStackTrace();
} finally {
    try { if (rs != null) rs.close(); } catch (SQLException e) { e.printStackTrace(); }
    try { if (pstmt != null) pstmt.close(); } catch (SQLException e) { e.printStackTrace(); }
    try { if (conn != null) conn.close(); } catch (SQLException e) { e.printStackTrace(); }
}
```

> Aunque esta forma funciona, es **m√°s propensa a errores** y mucho m√°s verbosa.

---

### üí° Recomendaciones clave

- Siempre usa `try-with-resources` si puedes.
- Nunca dejes conexiones abiertas en m√©todos que se ejecutan frecuentemente.
- Si usas un **pool de conexiones** (por ejemplo con Spring o HikariCP), devolver la conexi√≥n al pool tambi√©n se hace cerr√°ndola.

---

## 7. Ejemplo completo: Conectar, consultar y mostrar resultados

Este ejemplo muestra c√≥mo:

1. Conectarse a la base de datos.
2. Ejecutar una consulta usando `PreparedStatement`.
3. Recorrer un `ResultSet`.
4. Cerrar todos los recursos correctamente con `try-with-resources`.

---

### üì¶ Supongamos que tenemos esta tabla en MySQL

```sql
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100),
    email VARCHAR(100)
);

INSERT INTO users (name, email) VALUES ('Ana', 'ana@email.com');
INSERT INTO users (name, email) VALUES ('Luis', 'luis@email.com');
```

---

### ‚úÖ C√≥digo Java completo

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class EjemploJDBC {

    public static void main(String[] args) {
        // Datos de conexi√≥n
        String url = "jdbc:mysql://localhost:3306/testdb"; // Cambia testdb por tu base
        String user = "root"; // Usuario de la base de datos
        String password = "tu_contrase√±a"; // Contrase√±a

        // Consulta SQL con par√°metro
        String sql = "SELECT id, name, email FROM users WHERE name = ?";

        // Usamos try-with-resources para cerrar todo correctamente
        try (Connection conn = DriverManager.getConnection(url, user, password);
             PreparedStatement pstmt = conn.prepareStatement(sql)) {

            pstmt.setString(1, "Ana"); // Establecemos el par√°metro

            try (ResultSet rs = pstmt.executeQuery()) {
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    String email = rs.getString("email");

                    System.out.printf("ID: %d - Nombre: %s - Email: %s%n", id, name, email);
                }
            }

        } catch (SQLException e) {
            System.out.println("‚ùå Error al ejecutar la consulta:");
            e.printStackTrace();
        }
    }
}
```

---

### üß† ¬øQu√© estamos haciendo?

- Usamos `PreparedStatement` para evitar inyecciones SQL.
- Establecemos un par√°metro (`name = "Ana"`).
- Recorremos el `ResultSet` y mostramos los datos.
- Manejamos errores con `try-catch`.
- Cerramos autom√°ticamente todo gracias a `try-with-resources`.

---

## 8. Buenas pr√°cticas con JDBC

Estas recomendaciones te ayudar√°n a escribir c√≥digo m√°s limpio, seguro y eficiente al trabajar con JDBC:

---

### üîí Seguridad

- **Usa `PreparedStatement` siempre que haya par√°metros** en la consulta para prevenir inyecciones SQL.
- Nunca construyas strings SQL concatenando directamente datos de entrada del usuario.

---

### üßπ Gesti√≥n de recursos

- Usa **`try-with-resources`** siempre que puedas para asegurarte de cerrar conexiones, statements y result sets.
- No reutilices `Connection` o `Statement` en varios hilos sin sincronizaci√≥n (no son thread-safe).

---

### ‚ö†Ô∏è Manejo de errores

- Captura excepciones con `SQLException` y **muestra informaci√≥n √∫til** (`e.getMessage()`, `e.getErrorCode()`, `e.getSQLState()`).
- Registra los errores en un fichero de log si est√°s en producci√≥n.

---

### üîÅ Reutilizaci√≥n

- Extrae la l√≥gica de conexi√≥n y consulta en m√©todos o clases reutilizables.
- Considera usar un **pool de conexiones** (como HikariCP o Apache DBCP) para mejorar el rendimiento en aplicaciones grandes.

---

## 9. Consultas de escritura: `INSERT`, `UPDATE`, `DELETE`

Con JDBC no solo puedes hacer consultas `SELECT`, tambi√©n puedes modificar datos.

---

### ‚úèÔ∏è `INSERT` (a√±adir datos)

```java
String sql = "INSERT INTO users (name, email) VALUES (?, ?)";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql)) {

    pstmt.setString(1, "Mar√≠a");
    pstmt.setString(2, "maria@email.com");

    int filasInsertadas = pstmt.executeUpdate();
    System.out.println("Filas insertadas: " + filasInsertadas);

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### üîÅ `UPDATE` (modificar datos)

```java
String sql = "UPDATE users SET email = ? WHERE name = ?";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql)) {

    pstmt.setString(1, "nuevo@email.com");
    pstmt.setString(2, "Ana");

    int filasActualizadas = pstmt.executeUpdate();
    System.out.println("Filas actualizadas: " + filasActualizadas);

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### ‚ùå `DELETE` (eliminar datos)

```java
String sql = "DELETE FROM users WHERE name = ?";

try (Connection conn = DriverManager.getConnection(url, user, password);
     PreparedStatement pstmt = conn.prepareStatement(sql)) {

    pstmt.setString(1, "Luis");

    int filasEliminadas = pstmt.executeUpdate();
    System.out.println("Filas eliminadas: " + filasEliminadas);

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### üß† Nota

- Para `INSERT`, `UPDATE` y `DELETE` se usa `executeUpdate()` en lugar de `executeQuery()`.
- Este m√©todo devuelve un `int` con el n√∫mero de filas afectadas.

---

## 10. Manejo de transacciones

Una transacci√≥n permite agrupar varias operaciones SQL en una sola unidad l√≥gica: **todo o nada**. Es fundamental cuando modificas varias tablas o haces operaciones cr√≠ticas.

---

### üõ†Ô∏è Ejemplo b√°sico de transacci√≥n

```java
try (Connection conn = DriverManager.getConnection(url, user, password)) {
    conn.setAutoCommit(false); // Desactivamos el auto-commit

    try (PreparedStatement pstmt1 = conn.prepareStatement("INSERT INTO users (name, email) VALUES (?, ?)");
         PreparedStatement pstmt2 = conn.prepareStatement("UPDATE users SET email = ? WHERE name = ?")) {

        // Operaci√≥n 1
        pstmt1.setString(1, "Carlos");
        pstmt1.setString(2, "carlos@email.com");
        pstmt1.executeUpdate();

        // Operaci√≥n 2
        pstmt2.setString(1, "nuevo@email.com");
        pstmt2.setString(2, "Ana");
        pstmt2.executeUpdate();

        // Confirmamos ambas operaciones
        conn.commit();
        System.out.println("‚úÖ Transacci√≥n completada con √©xito");

    } catch (SQLException e) {
        conn.rollback(); // Deshacemos todo si falla algo
        System.out.println("‚ùå Transacci√≥n fallida. Cambios deshechos.");
        e.printStackTrace();
    }

} catch (SQLException e) {
    e.printStackTrace();
}
```

---

### üß† Importante

- Usa `conn.setAutoCommit(false)` para iniciar una transacci√≥n manual.
- Llama a `conn.commit()` al final si todo fue bien.
- Usa `conn.rollback()` en caso de error para deshacer los cambios.

---
